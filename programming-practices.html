<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>编程练习</title>
</head>
<body>
	<script type="text/javascript">
		// 逆波兰式
		function rp(str) {
			var arr = str.split('');
			var ops = '+-#*/'.split('')
			var result = [], temp = [];
			arr.forEach(function(ele, ind) {
				if (ele == '(') {
					temp.push(ele)
				} else if (ele == ')') {
					var flag = true;
					while (flag) {
						if (temp[temp.length-1] != '(') {
							result.push(temp.pop())
						} else {
							temp.pop();
							flag = false;
						}
					}
				} else if (ops.indexOf(ele) != -1) {
					cb(ele, temp)
					function cb(x, o) {
						if (o.length == 0 || o[o.length-1] == '(' || 
							ops.indexOf(x) - ops.indexOf(o[o.length-1]) > 2) {
							o.push(x)
						}  else {
							result.push(o.pop());
							return cb(x, o)
						}
					}
				} else {
					result.push(ele)
				}
			})
			while (temp.length > 0) {
				if(temp[temp.length-1] != '(') {
					result.push(temp.pop())
				} else {
					temp.pop()
				}
			}
			return result.join('');
		}
		// console.log(rp('(a+b)*c-(a+b)/e'))
		// console.log(rp('a+(b+c)*d-e'))

		//欧几里得算法
		function gcd (q, p) {
			return p == 0 ? q : gcd(p, q%p)
		}
		// console.log(gcd (4, 5))

		//插入排序
		function insert(arr, n) {
			for (var j = 1; j < arr.length; j ++) {
				var key = arr[j];
				var i = j - 1;
				while (i >= 0 && arr[i] >key) {
					arr[i+1] = arr[i];
					i = i -1;
					console.log(i)
				}
				arr[i+1] = key;
			}
			console.log(arr)
		}

		// insert([5, 7, 4, 6, 8, 3])

		'有两个各存放在数组A和数组B中的二进制整数，考虑他们的想加问题，结果存在的数组C中'
		// 思路：
		// 假设A.length <= B.length，从末位开始相加
		// 初始化一个结果栈，一个进位字符
		// 对于A和B当前位置的两个数a和b
		// 1.进位字符为0：
		//   若a和b都为0，将0推入结果栈
		//   若a和b一方为0一方为1，将1推入结果栈
		//   若a和b都为1，将0推入结果栈，进位字符设为1
		// 2.进位字符为1：
		//   若a和b都为0，将1推入结果栈并且将进位字符设为0
		//   若a和b一方为0一方为1，将0推入结果栈
    //   若a和b都为1，将1推入结果栈
    // 遍历结束后
    //   若进位字符为1
    //     若B内还有值未遍历，从B为遍历的最后一位开始做进位判断
    //     若B内无值未遍历，则将1推入结果
    //   若进位字符为0，B内还有字符未遍历
    //     将B内剩余字符推入结果栈

    function add(A, B) {
    	var result = [];
    	var flag = 0;
    	for (var i = A.length - 1, j = B.length - 1; i >= 0, j >= 0; i --, j --) {
    		if (flag == 0) {
	    		if (A[i] + B[j] == 0) {
	    			result.push(0);
	    		} else if (A[i] + B[j] == 1) {
	    			result.push(1);
	    		} else if (A[i] + B[j] == 2) {
	    			result.push(0);
	    			flag = 1;
	    		}
    		} else {
    			if (A[i] + B[j] == 0) {
	    			result.push(1);
	    			flag = 0;
	    		} else if (A[i] + B[j] == 1) {
	    			result.push(0);
	    		} else if (A[i] + B[j] == 2){
	    			result.push(1);
	    		}
    		}
    	}
    	if(flag == 1) {
    		if (B.length > A.length) {
    			var j = B.length - A.length-1
    			while (j >= 0) {
    				if (B[j] + flag == 0) {
		    			result.push(0);
		    		} else if (B[j] + flag == 1) {
		    			result.push(1);
		    			flag = 0;
		    		} else if (B[j] + flag == 2){
		    			result.push(0);
		    			flag = 1;
			    	} else {
		    			flag = 0;
		    		}
	    			j --;
    			}
    			if (flag) { result.push(1); }
	    	} else {
	  			result.push(1);
    		}
	    } else {
    		if (B.length > A.length) {
    			var j = B.length - A.length -1
    			while (j >= 0) {
    				result.push(B[j])
    				j --
    			}
    		}
    	}
    	console.log(result.reverse())
    }
    // add([1, 0, 1], [1, 1, 0])

    


	</script>
</body>
</html>