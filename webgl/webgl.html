<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>webgl</title>
  <style>
    #canvas {
      background: #ccc;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="500px" height="500px"></canvas>

  <div id="uiContainer">
    <div id="ui">
      <div id="x"></div>
      <div id="y"></div>
      <div id="angle"></div>
      <div id="scaleX"></div>
      <div id="scaleY"></div>
    </div>
  </div>
</body>
</html>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m3.js"></script>
<script id="2d-vertex-shader" type="x-shader/x-vertex">
  // 属性变量
  attribute vec2 a_position;
  attribute vec4 a_color;

  uniform mat3 u_matrix;

  varying vec4 v_color;

  void main () {
    gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);

    // v_color = gl_Position * 0.5 + 0.9;
    v_color = a_color;
  }
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
  precision mediump float;

  varying vec4 v_color;

  void main () {
    gl_FragColor = v_color;
  }
</script>

<script type="text/javascript">
  function main () {
    let canvas = document.getElementById("canvas")
    let gl = canvas.getContext("experimental-webgl")

    let program = webglUtils.createProgramFromScripts(gl, ['2d-vertex-shader', '2d-fragment-shader'])

    // 查询数据顶点的位置
    let positionAttributeLocation = gl.getAttribLocation(program, 'a_position')
    let colorLocation = gl.getAttribLocation(program, 'a_color')

    // 找到全局变量位置
    let matrixLocation = gl.getUniformLocation(program, 'u_matrix')

    // 给位置数据创建一个缓冲
    let positionBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)

    setGeometry(gl)

    // 缓冲操作是在GPU上获取顶点和其他顶点数据的一种方式。
    // gl.createBuffer创建一个缓冲；
    // gl.bindBuffer是设置缓冲为当前使用缓冲；
    // gl.bufferData将数据拷贝到缓冲，这个操作一般在初始化完成。
    var colorBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)

    setColors(gl)

    let translation = [200, 150]
    let angleInRadius = 0
    let scale = [1, 1]

    drawScene()

    webglLessonsUI.setupSlider('#x', {
      value: translation[0],
      slide: updatePosition(0),
      max: gl.canvas.width
    })

    webglLessonsUI.setupSlider('#y', {
      value: translation[1],
      slide: updatePosition(1),
      max: gl.canvas.height
    })

    webglLessonsUI.setupSlider('#angle', {
      slide: updateAngle,
      max: 360
    })

    webglLessonsUI.setupSlider('#scaleX', {
      value: scale[0],
      slide: updateScale(0),
      min: -5,
      max: 5,
      step: .01,
      precision: 2
    })

    webglLessonsUI.setupSlider('#scaleY', {
      value: scale[1],
      slide: updateScale(1),
      min: -5,
      max: 5,
      step: .01,
      precision: 2
    })

    function updatePosition (index) {
      return function (event, ui) {
        translation[index] = ui.value
        drawScene()
      }
    }

    function updateAngle (event, ui) {
      let angleInDegress = 360 - ui.value
      angleInRadius = angleInDegress * Math.PI / 180
      drawScene()
    }

    function updateScale (index) {
      return function (event, ui) {
        scale[index] = ui.value
        drawScene()
      }
    }

    function drawScene () {
      webglUtils.resizeCanvasToDisplaySize(gl.canvas)

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

      gl.clearColor(0, 0, 0, 0)
      gl.clear(gl.COLOR_BUFFER_BIT)

      gl.useProgram(program)

      gl.enableVertexAttribArray(positionBuffer)
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
      
      let size = 2
      let type = gl.FLOAT
      let normalize = false
      let stride = 0
      let offset = 0
      gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset)

      gl.enableVertexAttribArray(colorLocation)
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer) // 必要

      size = 4
      gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset)

      let matrix = m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight)
      matrix = m3.translate(matrix, translation[0], translation[1])
      matrix = m3.rotate(matrix, angleInRadius)
      matrix = m3.scale(matrix, scale[0], scale[1])

      gl.uniformMatrix3fv(matrixLocation, false, matrix)

      gl.drawArrays(gl.TRIANGLES, 0, 6)
    }
  }

  function randomInt (range) {
    return Math.floor(Math.random() * range)
  }

  function setRectangle (gl, x, y, width, height) {
    let x1 = x
    let x2 = x1 + width
    let y1 = y
    let y2 = y + height

    let positions = [
      x1, y1,
      x2, y1,
      x2, y2,
      x2, y2,
      x1, y1,
      x1, y2
    ]

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)
  }

  function setGeometry (gl) {
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        100, 120,
        -100, 120,
        100, -100,
        100, -100,
        -100, 120,
        -100, -100
      ]),
      gl.STATIC_DRAW
    )
  }

  function setColors (gl) {
    let r1 = Math.random()
    let b1 = Math.random()
    let g1 = Math.random()

    let r2 = Math.random()
    let b2 = Math.random()
    let g2 = Math.random()

    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        // r1, b1, g1, 1,
        // r1, b1, g1, 1,
        // r1, b1, g1, 1,
        // r2, b2, g2, 1,
        // r2, b2, g2, 1,
        // r2, b2, g2, 1
        Math.random(), Math.random(), Math.random(), 1,
        Math.random(), Math.random(), Math.random(), 1,
        Math.random(), Math.random(), Math.random(), 1,
        Math.random(), Math.random(), Math.random(), 1,
        Math.random(), Math.random(), Math.random(), 1,
        Math.random(), Math.random(), Math.random(), 1
      ]),
      gl.STATIC_DRAW
    )
  }


  main()

</script>