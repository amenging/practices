<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>webgl</title>
  <style>
    #canvas {
      background: #ccc;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="500px" height="500px"></canvas>

  <div id="uiContainer">
    <div id="ui">
      <div id="x"></div>
      <div id="y"></div>
      <div id="angle"></div>
      <div id="scaleX"></div>
      <div id="scaleY"></div>
    </div>
  </div>
</body>
</html>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m3.js"></script>
<script id="2d-vertex-shader" type="x-shader/x-vertex">
  // 属性变量
  attribute vec2 a_position;
  attribute vec2 a_texCoord;

  uniform vec2 u_resolution;

  varying vec2 v_texCoord;

  void main () {
    vec2 zeroToOne = a_position / u_resolution;
    vec2 zeroToTwo = zeroToOne * 2.0;
    vec2 clipSpace = zeroToTwo - 1.0;

    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);

    v_texCoord = a_texCoord;
  }
</script>

<script id="2d-fragment-shader" type="x-shader/x-fragment">
  precision mediump float;

  uniform sampler2D u_image;
  uniform vec2 u_textureSize;

  varying vec2 v_texCoord;

  void main () {
    vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;

    gl_FragColor = (
      texture2D(u_image, v_texCoord) +
      texture2D(u_image, v_texCoord + vec2(onePixel.x, 0.0)) +
      texture2D(u_image, v_texCoord + vec2(-onePixel.x, 0.0))
    ) / 3.0;
  }
</script>

<script type="text/javascript">
  function main () {
    let image = new Image()
    image.crossOrigin = ''
    image.src = 'https://webglfundamentals.org/webgl/resources/leaves.jpg'
    image.onload = function () {
      drawScene(image)
    }

    let canvas = document.getElementById("canvas")
    let gl = canvas.getContext("experimental-webgl")

    let program = webglUtils.createProgramFromScripts(gl, ['2d-vertex-shader', '2d-fragment-shader'])

    // 查询数据顶点的位置，询问顶点数据应该放在哪里
    let positionLocation = gl.getAttribLocation(program, 'a_position')
    let textcoordLocation = gl.getAttribLocation(program, 'a_texCoord')
    let textureSizeLocation = gl.getUniformLocation(program, 'u_textureSize')

    // 找到全局变量位置
    let matrixLocation = gl.getUniformLocation(program, 'u_matrix')
    let resolutionLocation = gl.getUniformLocation(program, 'u_resolution')

    // 给位置数据创建一个缓冲
    let positionBuffer = gl.createBuffer()
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)

    let translation = [200, 150]
    let angleInRadius = 0
    let scale = [1, 1]

    // webglLessonsUI.setupSlider('#x', {
    //   value: translation[0],
    //   slide: updatePosition(0),
    //   max: gl.canvas.width
    // })

    // webglLessonsUI.setupSlider('#y', {
    //   value: translation[1],
    //   slide: updatePosition(1),
    //   max: gl.canvas.height
    // })

    // webglLessonsUI.setupSlider('#angle', {
    //   slide: updateAngle,
    //   max: 360
    // })

    // webglLessonsUI.setupSlider('#scaleX', {
    //   value: scale[0],
    //   slide: updateScale(0),
    //   min: -5,
    //   max: 5,
    //   step: .01,
    //   precision: 2
    // })

    // webglLessonsUI.setupSlider('#scaleY', {
    //   value: scale[1],
    //   slide: updateScale(1),
    //   min: -5,
    //   max: 5,
    //   step: .01,
    //   precision: 2
    // })

    // function updatePosition (index) {
    //   return function (event, ui) {
    //     translation[index] = ui.value
    //     drawScene()
    //   }
    // }

    // function updateAngle (event, ui) {
    //   let angleInDegress = 360 - ui.value
    //   angleInRadius = angleInDegress * Math.PI / 180
    //   drawScene()
    // }

    // function updateScale (index) {
    //   return function (event, ui) {
    //     scale[index] = ui.value
    //     drawScene()
    //   }
    // }

    function drawScene (image) {
      setRectangle(gl, 0, 0, image.width, image.height)

      // 缓冲操作是在GPU上获取顶点和其他顶点数据的一种方式。
      // gl.createBuffer创建一个缓冲；
      // gl.bindBuffer是设置缓冲为当前使用缓冲；
      // gl.bufferData将数据拷贝到缓冲，这个操作一般在初始化完成。
      var textcoordBuffer = gl.createBuffer()
      gl.bindBuffer(gl.ARRAY_BUFFER, textcoordBuffer)
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
        1.0, 1.0
      ]), gl.STATIC_DRAW)

      let texture = gl.createTexture()
      gl.bindTexture(gl.TEXTURE_2D, texture)

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image)

      webglUtils.resizeCanvasToDisplaySize(gl.canvas)

      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

      gl.clearColor(0, 0, 0, 0)
      gl.clear(gl.COLOR_BUFFER_BIT)

      gl.useProgram(program)

      // 告诉webgl我们想从缓冲中提供数据
      gl.enableVertexAttribArray(positionLocation)
      // 将缓冲绑定到ARRAY_BUFFER绑定点
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
      
      let size = 2
      let type = gl.FLOAT
      let normalize = false
      let stride = 0
      let offset = 0
      // 告诉webgl从ARRAY_BUFFER绑定点当前绑定是缓冲获取数据等
      gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset)

      gl.enableVertexAttribArray(textcoordLocation)
      gl.bindBuffer(gl.ARRAY_BUFFER, textcoordBuffer) // 必要

      gl.vertexAttribPointer(textcoordLocation, size, type, normalize, stride, offset)

      // gl.uniform2f(textureSizeLocation, gl.canvas.width, gl.canvas.height)
      gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height)

      // let matrix = m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight)
      // matrix = m3.translate(matrix, translation[0], translation[1])
      // matrix = m3.rotate(matrix, angleInRadius)
      // matrix = m3.scale(matrix, scale[0], scale[1])

      // gl.uniformMatrix3fv(matrixLocation, false, matrix)

      gl.drawArrays(gl.TRIANGLES, 0, 6)
    }
  }

  function randomInt (range) {
    return Math.floor(Math.random() * range)
  }

  function setRectangle (gl, x, y, width, height) {
    let x1 = x
    let x2 = x1 + width
    let y1 = y
    let y2 = y + height

    let positions = [
      x1, y1,
      x2, y1,
      x1, y2,
      x1, y2,
      x2, y1,
      x2, y2,
    ]

    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)
  }

  function setGeometry (gl) {
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        100, 120,
        -100, 120,
        100, -100,
        100, -100,
        -100, 120,
        -100, -100
      ]),
      gl.STATIC_DRAW
    )
  }

  function setColors (gl) {
    let r1 = Math.random() * 256
    let b1 = Math.random() * 256
    let g1 = Math.random() * 256

    let r2 = Math.random() * 256
    let b2 = Math.random() * 256
    let g2 = Math.random() * 256

    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array([
        r1, b1, g1, 255,
        r1, b1, g1, 255,
        r1, b1, g1, 255,
        r2, b2, g2, 255,
        r2, b2, g2, 255,
        r2, b2, g2, 255
        // Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,
        // Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,
        // Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,
        // Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,
        // Math.random() * 256, Math.random() * 256, Math.random() * 256, 255,
        // Math.random() * 256, Math.random() * 256, Math.random() * 256, 255
      ]),
      gl.STATIC_DRAW
    )
  }


  main()

</script>